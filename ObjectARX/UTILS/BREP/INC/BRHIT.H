#ifndef AC_BRHIT_H
#define AC_BRHIT_H 1
// (C) Copyright 1996-1997 by Autodesk, Inc.
//
// Permission to use, copy, modify, and distribute this software in
// object code form for any purpose and without fee is hereby granted, 
// provided that the above copyright notice appears in all copies and 
// that both that copyright notice and the limited warranty and
// restricted rights notice below appear in all supporting 
// documentation.
//
// AUTODESK PROVIDES THIS PROGRAM "AS IS" AND WITH ALL FAULTS. 
// AUTODESK SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR USE.  AUTODESK, INC. 
// DOES NOT WARRANT THAT THE OPERATION OF THE PROGRAM WILL BE
// UNINTERRUPTED OR ERROR FREE.
//
// Use, duplication, or disclosure by the U.S. Government is subject to 
// restrictions set forth in FAR 52.227-19 (Commercial Computer
// Software - Restricted Rights) and DFAR 252.227-7013(c)(1)(ii)
// (Rights in Technical Data and Computer Software), as applicable.
//
// DESCRIPTION:
//
// The AcBrHit class is the interface class for contexted hits
// generated by line containment queries. All the functionality
// supported by this class is implemented by the class AcBrImpHit.
//
// This class defines the functions that are pertinent to contexted
// hits, and cannot be directly set by the user as the initialisation
// requirements are only available internally at the time of a call
// to AcBrEntity::getLineContainment(). It is derived from AcRxObject
// in order to provide full service run-time type-checking, etc.
//
// This class serves to contextualise all the hit data returned
// by line containment queries. A hit is a point at which a line
// is broken into segments by topological containment, or it may
// also correspond to one of the original end points of the line.
//
// The AcRxObject inherited isEqualTo() function is redefined to check
// content equality between two hit objects. If either object is invalid
// or is not a hit object, the function returns kFalse; kTrue is returned
// when the object is valid and has been equated to another valid hit
// object. Equivalence is defined as having the same hit path.
//
// The isNull() function tests whether the hit object has been set
// to anything meaningful. kTrue is returned if the hit object is
// uninitialised or invalidated (i.e., empty).
//
// The setHitPath() function is used to (re)set a hit to a specific hit
// path. If the hit path reference object is uninitialised or invalidated
// (i.e., empty), eInvalidInput is returned. If the AutoCAD entity
// associated with the line containment test that produced this hit
// changed since the hit path reference object's subentity path was last
// set, eInvalidInput is returned and the hit path reference object is
// invalidated (side effect). This function requires low-level data that
// is only available at the time of a call to getLineContainment(), so
// the hit path parameter is an unexported type.
//
// The getPoint() function returns the model space point that
// corresponds to the hit, which is the point in space where a line
// is broken into segments by topological containment. The model
// space point is returned as an AcGe 3d point, with the entire
// chain of transforms from the object ID array applied. The point
// is passed as a null AcGePoint3d reference pointer for getPoint()
// to instantiate. If the hit is uninitialised or invalidated (i.e.,
// empty), eInvalidObject is returned. If the AutoCAD entity associated
// with the line containment test that produced this hit changed since
// the hit path was last set, eBrepChanged is returned and the hit
// is invalidated. If the point geometry is missing, eMissingGeometry
// is returned. If the AcGe point comes back null, eOutOfMemory is
// returned. If any of the associated AutoCAD database objects from
// the chained transforms cannot be opened, eWrongObjectType is
// returned. In the event of an error, the point reference pointer
// is unchanged and thus likely points to a null object.
//
// The getEntityHit() function returns the dimensionally lowest
// topological entity which contains this hit. Note that the start
// and end points of lines are classified as hits so long as they pass
// a point containment test. It is not necessary for the ray which
// they define to pass through a geometric boundary; a hit may reside
// in the interior of a solid. The entity is passed as a null AcBrEntity
// reference pointer for getEntityHit() to instantiate. If the hit is
// uninitialised or invalidated (i.e., empty), eInvalidObject is returned.
// If the AutoCAD entity associated with the line containment test that
// produced this hit changed since the hit path was last set, eBrepChanged
// is returned and the hit is invalidated. If the entity hit is not a
// valid brep, face, edge or vertex in the associated AutoCAD entity,
// eAmbiguousOutput is returned. If the entity allocation comes back
// null, eOutOfMemory is returned. In the event of an error, the entity
// reference pointer is unchanged and thus likely points to a null object. 
//
// The getEntityEntered() function returns the dimensionally lowest
// topological entity which contains the segment along the original
// line bound by this hit and the next hit, or NULL if this is either
// the final hit in the hit array or the segment exits and then re-enters
// the object being tested. The entity is passed as a null AcBrEntity
// reference pointer for getEntityEntered() to instantiate. If the hit
// is uninitialised or invalidated (i.e., empty), eInvalidObject is
// returned. If the AutoCAD entity associated with the line containment
// test that produced this hit changed since the hit path was last set,
// eBrepChanged is returned and the hit is invalidated. If the entity
// entered is not a valid brep, face or edge in the associated AutoCAD
// entity, eAmbiguousOutput is returned. If the entity allocation comes
// back null, eOutOfMemory is returned. In the event of an error, the
// entity reference pointer is unchanged and thus likely points to a
// null object. 


#include "adesk.h"
#include "rxobject.h"
#include "rxboiler.h"
#include "brgbl.h"


// forward class declarations
class AcGePoint3d;
class AcBrEntity;
class AcBrHitPath;
class AcBrImpHit;


class AcBrHit : public AcRxObject
{
public:
    ACRX_DECLARE_MEMBERS(AcBrHit);
    AcBrHit();
    AcBrHit(const AcBrHit&);
    ~AcBrHit();

    // Assignment operator
    AcBrHit&            operator =      (const AcBrHit&);

    // Equivalence                    
    Adesk::Boolean      isEqualTo       (const AcRxObject* other) const;
    
    // Queries & Initialisers
    Adesk::Boolean      isNull          () const;
    AcBr::ErrorStatus   setHitPath	    (AcBrHitPath&);

    // Geometry
    AcBr::ErrorStatus   getPoint        (AcGePoint3d*&) const;

    // Topological Containment
    AcBr::ErrorStatus   getEntityHit    (AcBrEntity*&) const;
    AcBr::ErrorStatus   getEntityEntered(AcBrEntity*&) const;

protected:
    AcBrImpHit*         mpImp;
};


#endif

