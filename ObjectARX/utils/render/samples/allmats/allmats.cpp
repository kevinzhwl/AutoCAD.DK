// (C) Copyright 1997-2002 by Autodesk, Inc. 
//
// Permission to use, copy, modify, and distribute this software in
// object code form for any purpose and without fee is hereby granted, 
// provided that the above copyright notice appears in all copies and 
// that both that copyright notice and the limited warranty and
// restricted rights notice below appear in all supporting 
// documentation.
//
// AUTODESK PROVIDES THIS PROGRAM "AS IS" AND WITH ALL FAULTS. 
// AUTODESK SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR USE.  AUTODESK, INC. 
// DOES NOT WARRANT THAT THE OPERATION OF THE PROGRAM WILL BE
// UNINTERRUPTED OR ERROR FREE.
//
// Use, duplication, or disclosure by the U.S. Government is subject to 
// restrictions set forth in FAR 52.227-19 (Commercial Computer
// Software - Restricted Rights) and DFAR 252.227-7013(c)(1)(ii)
// (Rights in Technical Data and Computer Software), as applicable.
//

////////////////////////////////////////////////////////////////////////////////
// allmats.cpp
//
// Implements the command "allmats".
//
// (c:allmats file offset cube-size title-height)
//
// Argument     ADS Type    Description                     Default
// ========     ========    ===========                     =======
// file         RSTR        Path to the materials library   "Support/render.mli"
//                          file (.mli) to display
// offset       RT3DPOINT   Lower-left corner of the        '(0 0 0)
//                          display grid
// cube-size    RTREAL      Dimension of the cubes          1.0
// title-height RTREAL      Height of the title text        0.8
//                      
// Allmats draws a (roughly) square grid of cubes, one for each material in
// the specified material library, and applies a material to each.  Each cube
// is also titled with the name of the material, and the grid is titled with
// the name of the library file.
//
////////////////////////////////////////////////////////////////////////////////

#pragma warning( disable : 4514 ) // unreferenced inline function
                                  // (warning generated by math.h)
#include "rxdlinkr.h"
#include <math.h>
#include <string.h>
#include <rxdefs.h>
#include <avlib.h>
#include <dbapserv.h>

#define ELEMENTS(array) (sizeof(array) / sizeof((array)[0]))
#define RENDER_SERVICES /*MSG0*/"RENDER_SERVICES"

extern "C" AcRx::AppRetCode acrxEntryPoint(AcRx::AppMsgCode msg, void* );

////////////////////////////////////////////////////////////////////////////////
// ADS Function Table
////////////////////////////////////////////////////////////////////////////////

typedef struct {
    char        *name;
    AvErrorCode (*fptr)(struct resbuf *);
} FunctionTableEntry;

static AvErrorCode allmats(struct resbuf *);

FunctionTableEntry gFunctionTable[] = {
            {"C:ALLMATS",    allmats},
        };


////////////////////////////////////////////////////////////////////////////////
// Static function declarations
////////////////////////////////////////////////////////////////////////////////

static int dofun();
static int funcload();

static AvErrorCode drawMaterial(ads_point corner, double dCubeSize, 
                                char *sMaterial, char *sLibPath);
static int resbufListCount(struct resbuf *rb);
static void drawCube(ads_point p, double len);
static void drawMaterialName(ads_point p, double dHeight, char *name);
static void drawText(ads_point p, double dHeight, char *text);
static union ads_u_val * getArg(struct resbuf *rb, int restype, 
                                unsigned int position);


////////////////////////////////////////////////////////////////////////////////
// Rx Module Interface Functions
////////////////////////////////////////////////////////////////////////////////

extern AcRx::AppRetCode
acrxEntryPoint(AcRx::AppMsgCode msg, void* ptr)
{
    if (ptr != NULL) 
    {
        // We have been handed some kind of object
        // but we aren't going to do anything with it.
    }

    switch(msg) {
        case AcRx::kInitAppMsg:
            acrxDynamicLinker->registerAppMDIAware(ptr);
            acrxDynamicLinker->unlockApplication(ptr);
            break;
        case AcRx::kInvkSubrMsg:
            dofun();
            break;
        case AcRx::kLoadADSMsg:
            funcload();
            break;
        default:
            break;
    }
    return AcRx::kRetOK;
}


////////////////////////////////////////////////////////////////////////////////
// funcload()
//
// This function is called to define all function names in the ADS
// function table.  Each named function will be callable from lisp or
// invokable from another ADS application.
//
static int
funcload()
{
    unsigned short i;
    AvErrorCode retval;
    static int sbInitialized = FALSE;

    // AVLIB: we must call av_loadlib() to assure that Render.arx
    // is loaded.
    //
    if (!sbInitialized) {
        retval = av_loadlib();
        if (retval != AvRetNorm) {
            acdbFail("Library initialization failed.\n");
            return RTERROR;
        }
        sbInitialized = TRUE;
    }
    
    // call acedDefun() for each function name 
    // in gFunctionTable

    for (i = 0; i < ELEMENTS(gFunctionTable); i++) {
        if (acedDefun(gFunctionTable[i].name, (short)i) != RTNORM)
            return RTERROR;
    }

    return RTNORM;
}


////////////////////////////////////////////////////////////////////////////////
// dofun()
//
// This function calls the function in gGunctionTable that is indexed by
// the ADS function code.
//
static int
dofun()
{
    struct resbuf *rb;
    AvErrorCode retval;
    unsigned short func;

    // Reload Render.arx if it has been unloaded
    //
    if (! acrxServiceDictionary->at(RENDER_SERVICES))
    {
        retval = av_loadlib();
        if (retval != AvRetNorm) {
            acdbFail("Library initialization failed.\n");
            return RTERROR;
        }
    }

    func = (unsigned short)ads_getfuncode();
    if (func >= ELEMENTS(gFunctionTable))
    {
        acdbFail("Received nonexistent function code.");
        return RTERROR;
    }

    rb =  acedGetArgs();

    // AVLib: here, we call av_initialize, which issues
    // the "renderupdate" command
    //
    av_initialize();

    retval = (*gFunctionTable[func].fptr)(rb);

    acutRelRb(rb);

    if (retval == AvRetNorm)
        return RTNORM;
    else
        return RTERROR;
}


////////////////////////////////////////////////////////////////////////////////
// Functions added to template
////////////////////////////////////////////////////////////////////////////////

#define DEFAULT_LIBRARY_PATH    "Support/render.mli"
#define DEFAULT_OFFSET          0.0
#define DEFAULT_CUBE_SIZE       1.0
#define DEFAULT_TITLE_HEIGHT    0.8

////////////////////////////////////////////////////////////////////////////////
// allmats()
//
// Draw all of the materials in a given materials library file (.mli).
// The name of the library is passed in the resbuf (the only argument
// it processes).   The resbuf is NULL or not of type RTSTR, the displayed
// library will be "Support/render.mli".
//
// Returns AvRetNorm on success, otherwise, AvRetError.
//
static AvErrorCode
allmats(struct resbuf *rb)
{
    union ads_u_val *resval;
    char            *sLibPath,
                    *sLibName;
    AvMatlibParam   libParam;
    ads_point       corner,
                    offset;
    double          dCubeSize,
                    dCubeSpacing,
                    dLibNameHeight;
    struct resbuf   *pMaterial;
    int             numMaterials,
                    numRows,
                    i;

    // Get path of materials library to display
    //
    resval = getArg(rb, RTSTR, 0);
    if (resval == NULL)
	{
		acdbHostApplicationServices()->getRoamableRootFolder(sLibPath);
		strcat(sLibPath,DEFAULT_LIBRARY_PATH);
	}

    else
        sLibPath = resval->rstring;

    // Get offset position for drawing 
    //
    resval = getArg(rb, RT3DPOINT, 1);
    if (resval == NULL)
    {
        offset[X] = offset[Y] = offset[Z] = DEFAULT_OFFSET;
    }
    else
    {
        offset[X] = resval->rpoint[X];
        offset[Y] = resval->rpoint[Y];
        offset[Z] = resval->rpoint[Z];
    }

    // Get cube size
    //
    resval = getArg(rb, RTREAL, 2);
    if (resval == NULL || resval->rreal <= 0.0)
        dCubeSize = DEFAULT_CUBE_SIZE;
    else
        dCubeSize = resval->rreal;

    // Get title text height
    //
    resval = getArg(rb, RTREAL, 3);
    if (resval == NULL || resval->rreal <= 0.0)
        dLibNameHeight = DEFAULT_TITLE_HEIGHT;
    else
        dLibNameHeight = resval->rreal;

    
    // Make sLibName point to the library file name only
    //
    sLibName = sLibPath + strlen(sLibPath);
    while (sLibName > sLibPath) 
    {
        if (*sLibName == '/') 
        {
            sLibName++;
            break;
        }
        sLibName--;
    }

    acutPrintf("Displaying materials library %s (%s)\n", 
        sLibName, sLibPath);

    // Get list of materials in library
    //
    libParam.mode = AvMatlibList;
    libParam.libraryName = sLibPath;
    libParam.flags = AvMatlibLibrary;
    if (av_matlib(&libParam) != AvRetNorm)
        return AvRetError;

    pMaterial = libParam.stringList;
    numMaterials = resbufListCount(pMaterial);

    // Display library name, height = 0.8
    //
    drawText(offset, dLibNameHeight, sLibName);

    // Set Y offset for first material block
    //
    offset[Y] += dLibNameHeight * 1.5;

    numRows = (int)(sqrt((double)numMaterials)); // layout is square
    dCubeSpacing = dCubeSize * 1.5;

    // Draw each material in the library
    //
    for (i = 0; i < numMaterials; i++) 
    {
        // Find position
        //
        corner[X] = offset[X] + (i % numRows) * dCubeSpacing;
        corner[Y] = offset[Y] + (int)(i / numRows) * dCubeSpacing;
        corner[Z] = offset[Z];
        
        // Draw it
        //
        if (drawMaterial(corner, dCubeSize, 
            pMaterial->resval.rstring, sLibPath) != AvRetNorm)
            return AvRetError;

        pMaterial = pMaterial->rbnext;
    }

    acutRelRb(libParam.stringList);  // the start of pMaterial

    acutPrintf("Got %d materials\n", numMaterials);
    return AvRetNorm;
}


////////////////////////////////////////////////////////////////////////////////
// drawMaterial()
//
// Draws a cube of the dimension "dCubeSize" at the position "corner", draws the
// name of the material "sMaterial" under the cube, and applies the material
// "sMaterial" to the cube.
//
// Returns AvRetNorm unless it encounters an error in acdbEntLast(), in
// which case it returns AvRetError.
//
static AvErrorCode
drawMaterial(ads_point corner, double dCubeSize, 
             char *sMaterial, char *sLibPath)
{
    AvErrorCode    retval;
    AvMatlibParam  libParam;
    AvRmatParam    rmatParam;
    ads_name       entity,
                   selectionSet;

    drawCube(corner, dCubeSize);

    // Get the cube we just created
    //
    if (acdbEntLast(entity) != RTNORM) 
    {
        acdbFail("acdbEntLast failed\n");
        return AvRetError;
    }

    acedSSAdd(entity, NULL, selectionSet);

    drawMaterialName(corner, dCubeSize, sMaterial);

    // Retrieve the material from the library
    //
    libParam.mode = AvMatlibImport;
    libParam.libraryName = sLibPath;
    libParam.materialName = sMaterial;
    libParam.flags = AvMatlibMaterial | AvMatlibLibrary;
    if((retval = av_matlib(&libParam)) != AvRetNorm) 
    {
        acutPrintf("error: %s importing %s\n",
                   av_errorstr(retval),
                   sMaterial);
    }
    else
    {
        // Apply the material to the drawing
        //
        rmatParam.mode = AvRmatAttach;
        rmatParam.selectionSet[0] = selectionSet[0];
        rmatParam.selectionSet[1] = selectionSet[1];
        rmatParam.name = sMaterial;
        rmatParam.flags = AvRmatSelSet | AvRmatName;
        if((retval = av_rmat(&rmatParam)) != AvRetNorm) 
        {
            acutPrintf("error: %s attaching %s\n",
                       av_errorstr(retval),
                       sMaterial);
        } 
        else 
        {
            acutPrintf("attached material %s\n",
                        sMaterial);
        }
    }
    
    acedSSFree(selectionSet);

    return AvRetNorm;
}


////////////////////////////////////////////////////////////////////////////////
// Utility routines
////////////////////////////////////////////////////////////////////////////////


static int
resbufListCount(struct resbuf *rb)
{
    int count = 0;

    while (rb != NULL) 
    {
        rb = rb->rbnext;
        count++;
    }
    return count;
}


static void
drawCube(ads_point p, double dLength)
{
    acedCommand(RTSTR, "_.BOX",
                RT3DPOINT, p,    // postition
                RTSTR, "_Cube",
                RTREAL, dLength, // width, height, depth
                0);
}


static void
drawMaterialName(ads_point p, double dHeight, char *name)
{
    ads_point point;

    point[X] = p[X];
    point[Y] = p[Y] - dHeight / 5.0;
    point[Z] = p[Z];

    drawText(point, dHeight / 15.0, name);
}


static void 
drawText(ads_point position, double dHeight, char *text)
{
    acedCommand(RTSTR,     "_.TEXT",
                RT3DPOINT, position,
                RTREAL,    dHeight,
                RTREAL,    0.0, // rotation
                RTSTR,     text,
                0);
}


static union ads_u_val *
getArg(struct resbuf *rb, int restype, unsigned int position)
{
    unsigned int i;

    for (i = 0; i < position && rb != NULL; i++)
        rb = rb->rbnext;

    if (rb == NULL || rb->restype != restype)
        return NULL;

    return &(rb->resval);
}
